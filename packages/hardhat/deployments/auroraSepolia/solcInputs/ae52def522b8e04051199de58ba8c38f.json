{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/Voting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Voting {\n    uint256 public currentProtocol;\n    mapping(address => Protocol) public protocols;\n    mapping(uint256 => Proposal) public proposals; // (proposalId => Proposal)\n    mapping(uint256 => Vote[]) public votes; // (proposalId => Vote[])\n    mapping(uint256 => mapping(address => bool)) public voted; // (proposalId => userAddress => bool\n\n    event ProtocolAdded(\n        address indexed governance,\n        address indexed owner,\n        string descriptionIpfsHash,\n        uint256 votingTime,\n        uint256 commentTime,\n        uint256 percentageOfAgreement\n    );\n\n    event ProposalMade(\n        uint256 indexed proposalId,\n        address indexed governance,\n        string title,\n        string proposalIpfsHash,\n        uint256 startTime,\n        uint256 amountOfVotes,\n        SITUATION situation\n    );\n\n    event VotedForProposal(\n        uint256 indexed proposalId,\n        address indexed voter,\n        OPTION vote\n    );\n\n    event VotesSettled(\n        uint256 indexed proposalId,\n        SITUATION situation\n    );\n\n    enum SITUATION{\n        VOTING, \n        ACCEPTED,\n        UNACCPETED\n    }\n\n    enum OPTION{\n        AGREE,\n        ABSTAIN,\n        DISAGREE\n    }\n    \n    struct Protocol {\n        address owner;\n        string descriptionIpfsHash;\n        uint256 votingTime;\n        uint256 commentTime;\n        uint256 percentageOfAgreement;\n    }\n\n    struct Proposal {\n        uint256 id; // used to find the voters\n        address protocolAddress;\n        string title;\n        string proposal;\n        uint256 startTime;\n        uint256 amountOfVotes;\n        SITUATION situation;\n    }\n\n    struct Vote {\n        address voter;\n        OPTION vote;\n    }\n\n    constructor() {\n        currentProtocol = 0;\n    }\n\n    function addProtocol(\n        address _governance,\n        address _owner,\n        string memory _descriptionIpfsHash,\n        uint256 _votingTime,\n        uint256 _commentTime,\n        uint256 _percentageOfAgreement\n    ) external alreadyExists(_governance){\n        protocols[_governance] = Protocol(\n            _owner,\n            _descriptionIpfsHash,\n            _votingTime,\n            _commentTime,\n            _percentageOfAgreement\n        );\n\n        emit ProtocolAdded(\n            _governance,\n            _owner,\n            _descriptionIpfsHash,\n            _votingTime,\n            _commentTime,\n            _percentageOfAgreement\n        );\n    }\n\n    function makeProposal(\n        address _governance,\n        uint256 _id,\n        string memory _title,\n        string memory _description\n    ) external idNotUsed(_id) {\n        proposals[_id] = Proposal(\n            _id,\n            _governance,\n            _title,\n            _description,\n            block.timestamp,\n            0,\n            SITUATION.VOTING\n        );\n\n        emit ProposalMade(\n            _id,\n            _governance,\n            _title,\n            _description,\n            block.timestamp,\n            0,\n            SITUATION.VOTING\n        );\n    }\n    \n    function voteForProposal(\n        uint256 _proposalId,\n        OPTION _vote\n    ) external hasNotVoted(_proposalId) {\n        Proposal storage proposal = proposals[_proposalId];\n        Protocol storage protocol = protocols[proposal.protocolAddress];\n\n        require(_vote == OPTION.AGREE || _vote == OPTION.ABSTAIN || _vote == OPTION.DISAGREE, \"Invalid vote\");\n        require(proposal.startTime + protocol.votingTime >= block.timestamp, \"Time ended\");\n\n        votes[_proposalId].push(\n            Vote(\n                msg.sender,\n                _vote\n            )\n        );\n        voted[_proposalId][msg.sender] = true;\n\n        emit VotedForProposal(\n            _proposalId,\n            msg.sender,\n            _vote\n        );\n    }\n\n    function settleVotes(\n        uint256 _proposalId\n    ) external {\n        require(\n            proposals[_proposalId].situation == SITUATION.VOTING &&\n            block.timestamp >= proposals[_proposalId].startTime + protocols[proposals[_proposalId].protocolAddress].votingTime,\n            \"Voting not ended\"\n        );\n        Proposal storage proposal = proposals[_proposalId];\n        Protocol storage protocol = protocols[proposal.protocolAddress];\n        uint256 agree = 0;\n        uint256 disagree = 0;\n\n        for (uint256 i = 0; i < votes[_proposalId].length; i++) {\n            Vote storage vote = votes[_proposalId][i];\n\n            uint256 voterBalance = IERC20(proposal.protocolAddress).balanceOf(vote.voter);\n\n            if (vote.vote == OPTION.AGREE) {\n                agree += voterBalance;\n            } else if (vote.vote == OPTION.DISAGREE) {\n                disagree += voterBalance;\n            }\n        }\n\n        if(agree * 1e18 / (agree + disagree) >= protocol.percentageOfAgreement) {\n            proposal.situation = SITUATION.ACCEPTED;\n        } else {\n            proposal.situation = SITUATION.UNACCPETED;\n        }\n\n        emit VotesSettled(\n            _proposalId,\n            proposal.situation\n        );\n    }\n\n    modifier hasNotVoted(uint256 _proposalId) {\n        require(!voted[_proposalId][msg.sender], \"Already voted\");\n        _;\n    }\n    \n    modifier alreadyExists(address _governance) {\n        require(protocols[_governance].owner == address(0), \"Already exists\");\n        _;\n    }\n\n    modifier idNotUsed(uint256 _id) {\n        require(proposals[_id].protocolAddress == address(0), \"Id already used\");\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}